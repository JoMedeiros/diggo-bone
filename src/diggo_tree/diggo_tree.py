#!/usr/bin/env python3

import json
import os
import datetime

# TODO : first case
class Diggo_directory_manager:

	def __init__ (self, side, dirpath):
		self.SIDE = side
		self.SYNC_TREE = ''
		self.CURRENT_TREE = ''
		self.DIRPATH = dirpath

		self.load_tree(firstime=True)

	# REVIEW : edit timestamp tag
	def rec_json_tree(self, dirpath,tabs=1,sep=' '):
		"""
		função recursiva auxiliar que gera uma string formatada para ser interpretada
		pelo modulo json como um dicionário informando descrevendo
		um diretório 'dirpath' em formato de árvore. OBS: adicionar as chaves externas para funcionar.
		"""

		tree =''
		children = os.listdir(dirpath)
		for c in children:
			tree += (tabs*sep)+'"'+c+'":\n' # The name
			time_stamp = os.stat(dirpath+'/'+c).st_mtime
			ts_datetime = datetime.datetime.utcfromtimestamp(time_stamp).strftime('%Y-%m-%d %H:%M:%S')
			if (os.path.isfile(dirpath+'/'+c)):
				size = os.path.getsize(dirpath+'/'+c)
				tree+=tabs*sep+('{\n'
					+(tabs+1)*sep+'"type": "file",\n'
					+(tabs+1)*sep+'"status": "idle",\n'
					+(tabs+1)*sep+'"size_bytes": "'+str(size)+'",\n'
					+(tabs+1)*sep+'"timestamp": '+str(time_stamp)+',\n'
					+(tabs+1)*sep+'"datetime": \"'+str(ts_datetime)+'\"\n'
					+tabs*sep+'}')
			elif not os.listdir(dirpath+'/'+c):
				tree+=tabs*sep+('{\n'+
					(tabs+1)*sep+'"type": "empty_dir"\n'+
					tabs*sep+'}')
			else:
				tree+=tabs*sep+('{\n'
					+(tabs+1)*sep+'"type": "dir",\n'
					+(tabs+1)*sep+'"status": "idle",\n'
					+(tabs+1)*sep+'"timestamp": '+str(time_stamp)+',\n'
					+(tabs+1)*sep+'"datetime": \"'+str(ts_datetime)+'\",\n'
					+(tabs+1)*sep+('"children":\n'
						+(tabs+1)*sep+'{\n'
						+self.rec_json_tree(dirpath+'/'+c,tabs+2)) # Files and subdirs
					+(tabs+1)*sep+'}\n'+(tabs*sep)+'}')
			if c is not children[-1]:
				tree+=','
			tree+='\n'
		return tree

	def load_tree(self, treename="CURRENT_TREE", firstime=False):
		"""
		generates a dict with info about the tree 'treename' from a .json file.
		"""	
		if not firstime:
			f = open(treename.lower() + ".json", 'r')
			tree_dict = json.loads(f.read())
			f.close() # close file handler
		else:
			self.gen_current_tree()
			self.SYNC_TREE = self.CURRENT_TREE


	def save_tree(self, treename):
		"""
		generates a dict with info about the tree 'treename' from a .json file.
		"""	

		# choosing tree to save (DEFAULT to CURRENT_TREE)
		tree = self.CURRENT_TREE
		if treename == "SYNC_TREE":
			tree = self.SYNC_TREE

		f = open(treename.lower() + ".json", 'w')
		f.write(json.dumps(tree))

		f.close() # close file handler

	def gen_current_tree(self):
		"""
		updates self.CURRENT_TREE.
		"""

		rec_tree = self.rec_json_tree(self.DIRPATH)
		tree = "{\n" + rec_tree + "}"
		self.CURRENT_TREE = json.loads(tree)


	def get_diff_tree(self):
		"""
		generates a dict that says whats it's going to be updated before generating the sync tree.
		"""

		# diff_tree is generated by comparing CURRENT_TREE and SYNC_TREE

		pass

	def gen_sync_tree(self, diff_tree_client):
		"""
		returns a dictionary that represents the definitive
		directory tree after comparing the modifications between server's
		current sync tree and the client's difference tree
		"""

		# new_sync_tree is a generated by comparing server's SYNC_TREE 
		# 	with client's diff_tree.
		# gives priority to the most recent modified files/directories

		pass

	def apply_sync_tree(self):
		"""
		updates current directory tree based on a json representing
		the updated sync directory tree.
		"""

		# update CURRENT_TREE
		# update SYNC_TREE

		pass

	def update_current(self, path, type, newstatus):
		"""
		update one of the tree's leaf nodes (a node can be a directory,
		and leaf node can only be a file)
		"""

		# search for node in CURRENT_TREE
		# modify it

		split_path = path.split('/')
		path_len = len(split_path)
		d = self.CURRENT_TREE

		if newstatus == "new":
			for i in range(path_len):

				# se chegou na folha a ser adicionada
				if i == path_len-1:
					# alterar campos
					d[split_path[i]]["status"] = "new"
					d[split_path[i]]["type"] = "file"
					d[split_path[i]]["timestamp"] = "" #update
					d[split_path[i]]["datetime"] = "" #update

				# senão (está no meio do caminho)
				# 	se diretório já está na árvore
				elif split_path[i] in d:
					# diretorio "alterado"
					d[split_path[i]]['status'] = 'altered'
					d[split_path[i]]["timestamp"] = "" #update
					d[split_path[i]]["datetime"] = "" #update
				# 	se diretório não estiver na árvore
				elif:
					# diretorio adicionado
					d[split_path[i]]['status'] = 'new'
					d[split_path[i]]["type"] = "dir"
					d[split_path[i]]["timestamp"] = "" #update
					d[split_path[i]]["datetime"] = "" #update
					d[split_path[i]]["children"] = "" #update

				# próxima iteração: ir um diretório abaixo
				d = d[split_path[i]]['children']

		if newstatus == "delete":
			# primeiro round
			# CASO : remover diretorios um nivel abaixo (descendo)
			for i in range(path_len):

				# se chegou no item a ser removido OU passou dele 
				# 	item['status'] = 'deleted'

				continue

			# segundo round
			# CASO : remover diretorios acima (subindo)
			for i+path_len in range(path_len):
				
				# OBS: pra pular o ultimo é só fzr split_path[-1]

				# se o diretorio/item/dicionario atual NÃO é vazio, dado
				#	item['status'] = 'altered'

		if newstatus == "altered":
			# parecido com  "new"
			continue
				
		
		print(path_list)

		pass

# TEST
if __name__ == "__main__":
	TREE_MAN = Diggo_directory_manager(side='TEST', dirpath='test_directory')
	print(str(TREE_MAN.CURRENT_TREE))
	print("\n\n")
	TREE_MAN.update_current("newdir/newfile.txt")
	#TREE_MAN.save_tree("CURRENT_TREE")
	#TREE_MAN.save_tree("SYNC_TREE")

	print('Exiting...')